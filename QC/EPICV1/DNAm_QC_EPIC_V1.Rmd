---
params: 
  Title: "DNA Methylation Data Quality Control"
  Study_Name: ""
  Operator_Array: ""
  Operator_QC: ""
title: "`r params$Title`"
output: 
  html_document:
    toc: true
    toc_float: true

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Introduction
This is an R Markdown document for the Quality Control (QC) of Illumina EPIC microarray data of all the samples from the `r params$Study_Name` study.

Samples are not removed after each QC step, but a record is kept of samples which have already failed previous steps and the results of all tests are provided as output.

```{r loadingdata, include=FALSE, message = NA}

message("Loading libraries...")

suppressMessages(library(methylumi))
suppressMessages(library(wateRmelon))
suppressMessages(library(FlowSorted.Blood.EPIC))
suppressMessages(library(gdata))
suppressMessages(library(minfi))
suppressMessages(library(ggplot2))
suppressMessages(require(gridExtra))
suppressMessages(library(glmnet))
suppressMessages(library(yarrr))
suppressMessages(library(IlluminaHumanMethylationEPICmanifest))
suppressMessages(library(tidyr))
suppressMessages(library(dplyr))
suppressMessages(library(gplots))
suppressMessages(library("colorRamps"))
suppressMessages(library(IlluminaHumanMethylationEPICanno.ilm10b2.hg19))
suppressMessages(library("IlluminaHumanMethylationEPICanno.ilm10b4.hg19"))
suppressMessages(library("IlluminaHumanMethylation450kmanifest"))
suppressMessages(library("FlowSorted.DLPFC.450k"))
suppressMessages(library("FlowSorted.Blood.450k"))
suppressMessages(library("FlowSorted.CordBlood.450k"))
suppressMessages(library(CETYGO))
suppressMessages(library(stringr))

```


```{r ReadingArguments, cache = FALSE, echo = F, warning = F, message = NA}

message("Getting input arguments...")

args<-commandArgs(trailingOnly = T)

#WorkingDir=args[2]
ScriptDir=args[2]
OutPrefix=args[3]
idatPath=args[4]
SampleSheet_file=args[5]
Optional_Batches = trimws(str_split_1(args[6] , pattern = ","))
IntensityThreshold=as.numeric(args[7])

Mset_file=ifelse(is.na(OutPrefix),"",paste0(OutPrefix,"_EPICV1.Mset.rdat"))
RGset_file=ifelse(is.na(OutPrefix),"",paste0(OutPrefix,"_EPICV1.RGset.rdat"))
SamplesPassed=ifelse(is.na(OutPrefix),"",paste0(OutPrefix,"_EPICV1.SamplesPassedQC.csv"))
SamplesFailed=ifelse(is.na(OutPrefix),"",paste0(OutPrefix,"_EPICV1.SamplesFailedQC.csv"))
Normalised=ifelse(is.na(OutPrefix),"",paste0(OutPrefix,"_EPICV1.Normalized.rdat"))
CellCount=ifelse(is.na(OutPrefix),"",paste0(OutPrefix,"_EPICV1.CellCount.rdat"))

message("Input arguments:")
#message("    Working Directory: ",WorkingDir)
message("    Script Directory: ",ScriptDir)
message("    Output Prefix: ",OutPrefix)
message("    idat files Directory: ",idatPath)
message("    SampleSheet file: ",SampleSheet_file)
message("    Optional Batches: ",paste(Optional_Batches , sep = ","))
message("    Intensity Threshold: ",IntensityThreshold)
message("    Mset object file: ",Mset_file)
message("    RGset object file: ",RGset_file)
message("    Passed samplesSheet file: ",SamplesPassed)
message("    Failed samplesSheet file: ",SamplesFailed)
message("    Normalized object file: ",Normalised)

```

```{r LoadingData, cache = FALSE, echo = F, warning = F, message = NA}

message("Reading SampleSheet file...")

SampleSheet<-read.csv(file = SampleSheet_file, stringsAsFactors = FALSE, sep = ",", na.strings = c("","NA"))
mendatory_col = c("Sex",
"Basename",
"Meth_Control",
"Age",
"Organ")
if(Optional_Batches[1] != "")
  mendatory_col = c(mendatory_col , Optional_Batches)
if(!all(mendatory_col %in% colnames(SampleSheet))){
  stop("The following columns are not found in the SampleSheet file:\n",
       setdiff(mendatory_col , colnames(SampleSheet)))
}
SampleSheet$Basename2<-SampleSheet$Basename
SampleSheet<-separate(data = SampleSheet, col = Basename2, into = c("SentrixID", "Position"), sep="_")
SampleSheet$Sex <- trimws(SampleSheet$Sex)
SampleSheet$Sex <- as.factor(SampleSheet$Sex)

rownames(SampleSheet) <- SampleSheet$Basename

# SampleSheet$Empty <- is.na(SampleSheet$Sample_ID) 
SampleSheet$Control <- tolower(trimws(SampleSheet$Meth_Control)) == "yes"


## make chip name full (R often changes this to scientific notation)


if(file.exists(file=  Mset_file)){
  message(paste("Loading Mset:", Mset_file))
  load(file = Mset_file)
} else {
  message("Reading idat files to create the mset object...")
  msetEPIC <- readEPIC(idatPath=idatPath, barcodes=SampleSheet$Basename, parallel = T, force=T)
  message("Writing mset in ",Mset_file , "...")
  save(msetEPIC, file = Mset_file)
}

if(file.exists(file= RGset_file)){
  message(paste("Loading RGset:", RGset_file))
  load(file= RGset_file)
} else{
  message("Reading idat files to create the rgset object...")
  # For some data when we run pfilter function on mset, it seems it is unable to check/calculate the bead counts properly
  # and remove all probes. So, to resolve this issue, I set extended=TRUE in read.metharray.exp function to get an extended 
  # rgset and then apply the pfilter to the extended rgset
  RGset <- read.metharray.exp(base = idatPath, targets = SampleSheet, force = TRUE,extended = T,verbose = F)
  message("Writing rgset in ", RGset_file , "...")
  save(RGset, file =RGset_file )
}

```


# Study Information
**Study:** `r params$Study_Name`

**Arrays ran by:** `r params$Operator_Array`, The University of Exeter Medical School

**Array used:** Illumina EPIC microarray v1.0

**QC done by:**`r params$Operator_QC`, The University of Exeter Medical School

**Date of QC:** `r format(Sys.Date(), format="%d %B %Y")`

**Number of samples:** `r  nrow(SampleSheet)`

**Sample ages range:** `r  range(SampleSheet$Age, na.rm = TRUE)`

**Sample Tissue:** `r unique(SampleSheet$Organ)`

# QC Information 

```{r createQCmetrics, echo=FALSE, message=NA}

SampleSheet <- SampleSheet[order(rownames(SampleSheet)),]
msetEPIC <- msetEPIC[,order(colnames(msetEPIC))]
if(identical(rownames(SampleSheet), colnames(msetEPIC))){
  message("mSET and pheno samples match")
} else{
  message("mSET and pheno samples do not match")
  exit()
}

#QC metrics can be be bound on to the end of a copy of the sample sheet 
QCmetrics<-SampleSheet

#SamplesFail will be our boolean record of which samples have already failed
SamplesFail<-as.logical(rep("FALSE", nrow(SampleSheet)))
#Entries will be changed to TRUE as samples fail 

Stepsummary<-as.data.frame(matrix(ncol=0, nrow=2))
rownames(Stepsummary)<-c("Failed This Step", "Total Failed")
```

The phenotype file containing the sample information was loaded into R. Then the methylation data for the `r nrow(SampleSheet)` samples were loaded into a methylumiset. This contains `r nrow(SampleSheet[!(SampleSheet$Control),])` `r params$Study_Name` and `r nrow(SampleSheet[SampleSheet$Control,])` fully methylated control samples.

# Check Signal Intensities
The intensity check is the biggest indicator of sample quality. The median methylated signal intensity and unmethylated signal intensity for each sample is calculcated.

```{r medianintensities, include=FALSE}
m_intensities<-methylated(msetEPIC)
u_intensities<-unmethylated(msetEPIC)
M.median<-apply(m_intensities, 2, median)
U.median<-apply(u_intensities, 2, median)
QCmetrics<-cbind(SampleSheet,M.median, U.median)
```

A histogram and scatter plot of the resulting data are plotted to visualise the data quality. Samples are coloured by `r paste(Optional_Batches , collapse=",")`, to make sure there are no batch effects.

```{r plotintensities, echo=FALSE}

par(mfrow = c(1,2))
hist(M.median, xlab = "Median M intensity", main="Histogram of Median Methylated Intensities", cex.main=0.7)
hist(U.median, xlab = "Median U intensity", main="Histogram of Median Unmethylated Intensities", cex.main=0.7)

if(Optional_Batches[1] != ""){
  for (b in Optional_Batches) {
    if(length(unique(SampleSheet[,b])) > 2){
      plotfactor<-factor(SampleSheet[,b], levels=c(unique(SampleSheet[,b]))) 
      par(mfrow = c(1,1))
      plot(M.median, U.median, pch = 16, xlab = "Median M intensity", ylab = "Median U intensity", 
           col = rainbow(nlevels(plotfactor))[factor(plotfactor)], 
           main=paste("Scatter plot of Signal Intensities coloured by",b))
      par(xpd=TRUE)
      legend("topright", levels(factor(plotfactor)), col = rainbow(nlevels(plotfactor)), pch = 10, cex=0.5)
    }
  
  }
}


#coloured by plate
plotfactor<-factor(SampleSheet$Plate, levels=c(unique(SampleSheet$Plate)))
par(mfrow = c(1,1))
plot(M.median, U.median, pch = 16, xlab = "Median M intensity", ylab = "Median U intensity", col = rainbow(nlevels(plotfactor))[factor(plotfactor)], main="Scatter plot of Signal Intensities coloured by plate")
par(xpd=TRUE)
legend("topright", levels(factor(plotfactor)), col = rainbow(nlevels(plotfactor)), pch = 10, cex=0.5)

##Coloured by Organ
plotfactor<-factor(SampleSheet$Organ, levels=c(unique(SampleSheet$Organ)))
par(mfrow = c(1,1))
plot(M.median, U.median, pch = 16, xlab = "Median M intensity", ylab = "Median U intensity", col = rainbow(nlevels(plotfactor))[factor(plotfactor)], main="Scatter plot of Signal Intensities coloured by Organ")
par(xpd=TRUE)
legend("topright", levels(factor(plotfactor)), col = rainbow(nlevels(plotfactor)), pch = 10, cex=0.5)


##Coloured by SentrixID
plotfactor<-factor(SampleSheet$SentrixID, levels=c(unique(SampleSheet$SentrixID)))
par(mfrow = c(1,1))
plot(M.median, U.median, pch = 16, xlab = "Median M intensity", ylab = "Median U intensity", col = rainbow(nlevels(plotfactor))[factor(plotfactor)], main="Scatter plot of Signal Intensities coloured by SentrixID")
par(xpd=TRUE)
legend("topright", levels(factor(plotfactor)), col = rainbow(nlevels(plotfactor)), pch = 10, cex=0.5)

```

The signal intensities are okay for these samples.
 
To further investigate the plates we can plot heatmaps of the intensities, shown below.

```{r intensityheatmap, echo=FALSE}
QCmetrics$ratio <- QCmetrics$M.median - QCmetrics$U.median
QCmetrics$position<-factor(QCmetrics$Position)
QCmetrics$SentrixID<-factor(QCmetrics$SentrixID, levels=rev(unique(QCmetrics$SentrixID))) #keeps the levels of the factor in current order rather than sorting numerically/alphabetically, also reverses this order as heatmaps plot bottom to top

plates<-unique(QCmetrics$Plate)


#extract the legend (using a function found online)
g_legend<-function(a.gplot){
    tmp <- ggplot_gtable(ggplot_build(a.gplot))
    leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
    legend <- tmp$grobs[[leg]]
    legend
}

for(plate in plates){
  samples<-QCmetrics[which(QCmetrics$Plate == plate),]
  control<-samples[samples$Control,]

  plateHeatmap <- ggplot(data=samples, aes(x=Position, y=SentrixID)) +
    scale_fill_gradientn(colours=colorRamps::matlab.like(100), limits=c(min(QCmetrics$U.median),max(QCmetrics$M.median))) +
    labs(x="", y="") +
    theme_minimal() + 
    coord_equal() +
    theme(plot.title = element_text(hjust = 0.5), axis.text.x = element_text(angle = 90, hjust=1))
  
  plot1 <- plateHeatmap +
    ggtitle("Median Methylated Intensity") +
    geom_tile(aes(fill=M.median), colour = "white") +
    geom_point(data=control, aes(x=Position, y=SentrixID)) +
    theme(legend.position = "none")
  
  plot2 <- plateHeatmap +
    ggtitle("Median Unmethylated Intensity") +
    geom_tile(aes(fill=U.median), colour = "white") +
    geom_point(data=control, aes(x=Position, y=SentrixID)) +
    theme(legend.position = "none")
  
  legendplot<-plateHeatmap + 
    geom_tile(aes(fill=U.median), colour = "white") +
    labs(fill="Intensity", alpha="Control") +
    geom_point(data=control, aes(x=Position, y=SentrixID, alpha=Control)) +
    scale_alpha_manual(values=c(1,1,1)) + 
    guides(alpha = guide_legend(override.aes = list(colour="black", pch=16)))
    
  legend<-g_legend(legendplot)
  
  grid.arrange(plot1, plot2, legend, ncol=3, widths=c(3/7, 3/7, 1/7), top=paste("", plate))
}
```

```{r heatmap of Meth and unmeth ratios, echo= FALSE}

for(plate in plates){
  samples<-QCmetrics[which(QCmetrics$Plate == plate),]
  control<-samples[samples$Control,]

  plateHeatmap <- ggplot(data=samples, aes(x=Position, y=SentrixID)) +
    scale_fill_gradientn(colours=colorRamps::matlab.like(100), limits=c(min(QCmetrics$ratio),max(QCmetrics$ratio))) +
    labs(x="", y="") +
    theme_minimal() + 
    coord_equal() +
    theme(plot.title = element_text(hjust = 0.5), axis.text.x = element_text(angle = 90, hjust=1))
  
    plot3 <- plateHeatmap +
    ggtitle("Ratio of median methylated and median unmethylated Intensity") +
    geom_tile(aes(fill=ratio), colour = "white") +
    geom_point(data=control, aes(x=Position, y=SentrixID)) +
    theme(legend.position = "none")

  legendplot<-plateHeatmap + 
    geom_tile(aes(fill=U.median), colour = "white") +
    labs(fill="Intensity", alpha="Control") +
    geom_point(data=control, aes(x=Position, y=SentrixID, alpha=Control)) +
    scale_alpha_manual(values=c(1,1,1)) + 
    guides(alpha = guide_legend(override.aes = list(colour="black", pch=16)))
    
  legend<-g_legend(legendplot)
  
  grid.arrange(plot3, legend, ncol=2, widths=c(6/7, 1/7), top=paste("", plate))
}
```



The heatmaps show that the signal intensities are generally high


```{r removecontrols, include=FALSE}
#identical(rownames(QCmetrics), colnames(RGset))
RGset <- RGset[,rownames(QCmetrics) , drop = FALSE]

#identical(rownames(QCmetrics), colnames(RGset))


#remove methylation controls from all variables
M.median<-M.median[!SampleSheet$Control]
U.median<-U.median[!SampleSheet$Control]
msetEPIC<-msetEPIC[,!SampleSheet$Control]
RGset<-RGset[,!SampleSheet$Control]
SamplesFail<-SamplesFail[!SampleSheet$Control]
QCmetrics<-QCmetrics[!SampleSheet$Control,]
SampleSheet<-SampleSheet[!SampleSheet$Control,]


## remove the empty 'samples'
# M.median<-M.median[!SampleSheet$Empty]
# U.median<-U.median[!SampleSheet$Empty]
# msetEPIC<-msetEPIC[,!SampleSheet$Empty]
# RGset<-RGset[,!SampleSheet$Empty]
# SamplesFail<-SamplesFail[!SampleSheet$Empty]
# QCmetrics<-QCmetrics[!SampleSheet$Empty,]
# SampleSheet<-SampleSheet[!SampleSheet$Empty,]

```

Although signal intensity is the largest predictor of sample quality, the threshold at which to exclude samples can vary from experiment to experiment - for example, signal intensities can vary slightly depending on tissue type or DNA extraction method. Samples which clearly deviate from the main cluster on the signal intensity plots should be removed. 

```{r, echo = FALSE}

lowintensitysamples<-which(M.median < IntensityThreshold | U.median < IntensityThreshold)
```

```{r scatter500, echo=FALSE}
Intensity<-rep("OK", nrow(SampleSheet))
Intensity[lowintensitysamples] <-"LowIntensity"

plotfactor<-as.factor(Intensity)

plot(M.median, U.median, pch = 16, xlab = "Median M intensity", ylab = "Median U intensity", col=rainbow(2)[factor(plotfactor)])
abline(v = IntensityThreshold, col = "red")
abline(h = IntensityThreshold, col = "red")
legend("topleft", levels(factor(plotfactor)), pch = 16, col = rainbow(2))
```


```{r updateQCmetrics1, include=FALSE}
SamplesFail[which(Intensity=="LowIntensity")]<-TRUE
QCmetrics<-cbind(QCmetrics, Intensity)
Step1<-c(sum(Intensity=="LowIntensity"),sum(SamplesFail))
Stepsummary<-cbind(Stepsummary,Step1)
```


```{r Stepsummary1}
print(Stepsummary)
```


# Bisulphite Conversion
A bisulphite conversion statistic for each sample was calculated, and a histogram of the results plotted.

```{r bisulphiteconversion, echo=FALSE}
Bisulphite<-bscon(msetEPIC)
hist(Bisulphite, xlab = "Median % BS conversion", main = "Histogram of Bisulphite Converstion Statistics")
```

Samples with a conversion < 80% fail the QC, so with this threshold `r sum(Bisulphite<80)` samples fail the QC, and will be removed at a later stage.


```{r updateQCmetrics2, include=FALSE}
QCmetrics<-cbind(QCmetrics, Bisulphite)
SamplesFail[which(Bisulphite<80)]<-TRUE
Step2<-c(sum(Bisulphite<80, na.rm=T),sum(SamplesFail))
Stepsummary<-cbind(Stepsummary,Step2)


bisulphite_fail <- QCmetrics[SamplesFail,]
```

```{r Stepsummary2}
print(Stepsummary)
```


# Sex Check
A principal component analysis of the methylation data can be used to predict the sex of the samples.

The principal components are calculated, and the two which correlate most with sex are found. These can be used to generate a scatter plot where the sexes are clearly separated.



```{r sex check minfi, warning = FALSE, echo = FALSE, message= FALSE}
GRset <- mapToGenome(RGset)


predictedSex1 <- getSex(GRset, cutoff = -2)

Sexplot_data <- as.data.frame(predictedSex1)
Sexplot_data <- Sexplot_data[order(row.names(Sexplot_data)),]
PredictedSex <-Sexplot_data$predictedSex
QCmetrics <- cbind(QCmetrics,PredictedSex)

#here we add the reported sex data
Sexplot_data <- cbind(Sexplot_data, QCmetrics$Sex)
colnames(Sexplot_data)[colnames(Sexplot_data)=="QCmetrics$Sex"] <- "Reported Sex"
#replace blanks with NA
Sexplot_data$`Reported Sex`[Sexplot_data$`Reported Sex` == ""] <- "NA"

ggplot(Sexplot_data, aes(xMed,yMed,colour = `Reported Sex`)) +
                  geom_point() +
                  labs(x= "X Chr, median total intensity (log2)",
                       y ="Y Chr, median total intensity (log2)",
                       colour = "Reported Sex")

```

```{r updateQCmetrics3, include=FALSE}

ReportedSex <- as.character(QCmetrics$Sex)
QCmetrics$MismatchSex<-PredictedSex!=ReportedSex
SamplesFail[which(PredictedSex!=ReportedSex)]<-TRUE
Step3<-c(length(which(PredictedSex!=ReportedSex)),sum(SamplesFail))
Stepsummary<-cbind(Stepsummary,Step3)
```

Here `r sum(PredictedSex!=ReportedSex, na.rm=T)` number of sampless predicted sex does not match their reported sex. These samples fail the QC according to the findGenderPC function and, and will be removed.

```{r Stepsummary3}
print(Stepsummary)
```

<!--
## Genotype Sex Check
If there is SNP data available the reported sex will be comapred to the sex predicted using the SNP data and samples which do not match will be removed. 

If SNP data is not available this step will be ignored, as there is no fam file for this data this step will be ignored however it will be left here as referance.


```{R check sex agaisnt genotype sex, include=FALSE}
# if(!is.na(SampleSheet[1,"DNA_IID"])){
# fam<-read.table(fam_file)
# fam$V5[fam$V5==0]<-NA
# # (1 = male, 2 = female, 0 = unknown)
# # recode so that it matches the rest of the file for comparison
# fam$V5[fam$V5==1]<-"M"
# fam$V5[fam$V5==2]<-"F"
# 
# ### match the datasets
# fam$V2 <- as.character(fam$V2)
# fam<-fam[match(QCmetrics$DNA_IID, fam$V2),]
# 
# #### count mis matches between pheno and geno and predicted and geno
# 
# MMpred<-fam[which(fam$V5 != PredictedSex),] ## 19
# MMpheno<-fam[which(fam$V5 != ReportedSex),] ## 14
# overlapMM<-MMpred[which(MMpred$V1 %in% MMpheno$V1),] ## 8
# 
# QCmetrics<-cbind(QCmetrics, geno_sex=fam$V5)
# QCmetrics$geno_sex[QCmetrics$geno_sex==0]<-NA
# QCmetrics$Mismatch_pheno_geno_Sex<-ReportedSex!= QCmetrics$geno_sex
# QCmetrics$Mismatch_predicted_geno_SeX<-PredictedSex!= QCmetrics$geno_sex
# }
```
-->


<!--
# Check Genotypes

On the EPIC array there are 59 SNP probes. If  have SNP data is present, we can compare the methylation on these SNP probes to the samples genotypes to confirm samples are from the expected individual.

If SNP data is not available this step will be ignored.

```{r load genotypes, include=FALSE}
#Skip Genotyping if there are more than unique(plates) NA's. EG if there are three plates there should only be three NA's. If more than three NA's in the DNA_IID column assumption is made that there are no genotyping data available.

# if(!is.na(SampleSheet[1,"DNA_IID"])){
# betas<-betas(msetEPIC)
# 
# # load genotypes and match to betas
# 
# geno<-read.csv(Genotype, row.names = 1, h=T) #The second row is where the samples are unique to individuals
# ID<-SampleSheet[match(rownames(geno),SampleSheet$DNA_IID),] #select samples from samplesheet that has genotype data
# geno<-geno[match(SampleSheet$DNA_IID, rownames(geno)),] #select genotype sample that have array data
# id<-geno[-which(rownames(geno) %in% SampleSheet$DNA_IID),] #geno samples which do not have array data
# 
# 
# 
# a<-NULL
# for(i in 1:ncol(geno)){
# 	snp<-unlist(strsplit(colnames(geno)[i], "_"))[1]
# 	a<-append(a, grep(snp, rownames(betas)))
# }
# 
# meth.sub<-betas[a,]
# 
# 
# 
# #finding number of available genotypes for each sample
# 
# nGenos<-rep(NA, length=nrow(SampleSheet))
# for(i in 1:nrow(SampleSheet)){
#   nGenos[i]<-sum(!is.na(geno[i,]))
# }
# 
# # first check direction of minor alleles
# 
# cors<-vector(length = length(a))
# par(mfrow=c(2,3))
# for(each in 1:nrow(meth.sub)){
# 	cors[each]<-cor(geno[,each], meth.sub[each,], use = "pairwise.complete.obs")
# 	plot(geno[,each], meth.sub[each,], xlab = "Genotype", ylab = "Methylation", main = rownames(meth.sub)[each], pch = 16, xlim = c(0,2), ylim = c(0,1), cex = 0.7)
# }
# 
# # change minor allele in genotype data if negative correlation
# 
# for(each in which(cors < 0)){
# 	geno[,each]<-(2-geno[,each])
# }
# 
# #samples which seem incorrect
# 
# mismatchsamples<-which(cors<0.8)
# par(mfrow=c(2,3))
# for (i in mismatchsamples){
# 	plot(geno[,each], meth.sub[each,], xlab = "Genotype", ylab = "Methylation", main = rownames(meth.sub)[each], pch = 16, xlim = c(0,2), ylim = c(0,1), cex = 0.7)
# }
# }

```
-->
<!--
To ensure that the correct samples are loaded onto the EPIC array and that it matches their genotyping information, we will calculate the correlation between SNPs on the EPIC array and on the genotyping array. Correlation values lower than 0.8 suggests that the samples from the methylation and genotyping do not match. These samples will need to be further investigated to understanding what issues may have risen such as mislabelling samples or sample switch on either arrays. 
First, we will check the number of SNPs that individuals share between the EPIC and the genotyping array. The SNPs on the DNAm array and the SNPs on the genotyping array may not always match for all individuals, the table below is the summary for this study. 

```{r ngenos, echo = FALSE, include=FALSE}
# if(exists('nGenos')){
# tblnGenos <- as.data.frame(table(nGenos))
# tblnGenos$nGenos <- as.numeric(as.character(tblnGenos$nGenos))
# tblnGenos <- t(tblnGenos)
# rownames(tblnGenos) <- c('Snps shared between\nDNAm array & SNP array',
#                          'Number of samples')
# grid.table(tblnGenos)
# } else {
#   message('No Genotype data to compare snps on DNAm array and SNP array')
# }

```
-->
<!--
Now we can check the correlation between the methylation and genotyped samples.

```{r check genotypes correlations, include=FALSE}
# if(exists('geno')){
#   #check genotypes correlation with methylation per sample
#   GenoCor<-rep(NA, nrow(SampleSheet))
#   for(i in 1:ncol(meth.sub)){
#     GenoCor[i]<-cor(as.numeric(geno[i,]), meth.sub[,i], use = "pairwise.complete.obs")
#   }
# #plot histogram of correlations
#   hist(GenoCor)
# 
# }

  
```
-->
<!--
A failed sample is where the methyaltion and genotype correlation is low for a SNP, an example is provided here below.

```{r examplefailedgenotypes, include=FALSE}
# if(!is.na(SampleSheet[1,"DNA_IID"])){
# par(mfrow=c(1,2))
# examples=c(which(GenoCor>0.8)[1],which(GenoCor<0.8)[1])
# titles=c("Passed Sample","Failed Sample")
# 
# for (n in 1:2){
# i=examples[n]
# plot(as.numeric(geno[i,]), meth.sub[,i], main =titles[n], xlab = "Genotype", ylab = "Methylation", xlim = c(0,2), ylim = c(0,1), pch = 16)
# legend("topleft", legend=paste("r=",round(GenoCor[i],3)), bty="n")
# }
# }
```


```{r updateQCmetrics4, include=FALSE}

# if(!is.na(SampleSheet[1,"DNA_IID"])){
# QCmetrics<-cbind(QCmetrics, GenoCor)
# SamplesFail[which(GenoCor<0.8)]<-TRUE
# Step4<-c(sum(GenoCor<0.8, na.rm=T),sum(SamplesFail))
# Stepsummary<-cbind(Stepsummary,Step4)
# genocorr<-subset(QCmetrics, GenoCor < 0.8)
# }

```

```{r Stepsummary4}
#print(Stepsummary)
```
-->
<!--
## Genetic correlations

The 59 SNP probes on the array can also be used to estimate genetic correlations between samples. 

This small number of probes means that only identical samples (such as samples from the same individual, MZ twins, individual brainIDs or samples duplicated by error) can be identified and no lower proportion of genetic relatedness (such as siblings) can be inferred.

If your study is not a paired design this step will be skipped

```{r calculate snpCor, include=FALSE}


# betas<-betas(msetEPIC)
# betas.rs<-betas[grep("rs", rownames(betas)),]
# snpCor<-cor(betas.rs, use = "pairwise.complete.obs")
# for(i in 1:ncol(betas.rs)){
# 	snpCor[i,i]<-NA
# }


```
-->
<!--

## Checking samples from unrelated individuals
This study design assumes that each sample is completely unqiue and that there should be no duplicates with any other sample. The SNPs on the DNAm array can be used to predicted that no sample correlates with another. For each sample, we can find its maximum correlation with any other sample, and plot a histogram of the results. Any samples with a threshold greater than 0.8 indicates that they are duplicates.

```{r checkingunrelatedcor, include=FALSE}
# Individual_IDs<-unique(SampleSheet$Family_ID) 
# unrelatedcors<-snpCor
# for (i in Individual_IDs){
#   samples<-which(SampleSheet$Family_ID == i)
#   unrelatedcors[samples,samples]<-NA
# }
# maxunrelatedcors<-apply(unrelatedcors, 1, max, na.rm = TRUE)
# 
# hist(maxunrelatedcors, main="Maximum correlation in samples from unrelated individuals", xlab="Max Correlation")
#  
# 
# #Sometimes samples are duplicates and we can check that there is also duplicates in the genotype data if necessary.
```
-->
<!--
`r #length(which(maxunrelatedcors>0.8))` samples have a maximum correlation > 0.8 with another unrelated sample.

```{r update QCmetrics6, include=FALSE}
# #To ensure that samples are truly duplicates we will check geno and methylation samples are also duplicates
# 
# dupsmeth <- rownames(as.matrix(which(maxunrelatedcors > 0.8, arr.ind = T)))
# dupsmeth <- QCmetrics[which(QCmetrics$Basename %in% dupsmeth), "DNA_IID"]
# 
# QCmetrics<-cbind(QCmetrics,maxunrelatedcors)
# 
#  
# 
#  
# SamplesFail[which(maxunrelatedcors > 0.8)]<-TRUE
# Step6<-c(sum(maxunrelatedcors > 0.8),sum(SamplesFail))
#    
# dup<-QCmetrics[which(QCmetrics$maxunrelatedcors > 0.8),]
# write.csv(dup, "duplicated_samples.csv", row.names=F)
# 
# 
# Stepsummary<-cbind(Stepsummary,Step6)
# 
# ```
# 
# ```{r Stepsummary6}
# print(Stepsummary)

``` 
-->

# Age Prediction
The age of samples can be predicted from their methylation data using Horvath's Coefficients and compared to the samples' reported ages. 

However, this can be inaccurate and so it is used as a quality check and not as a reason to remove samples. Therefore, the following plot only contains samples which have passed the previous QC steps.

```{r dnamage, echo=FALSE}
QCmetrics$Age <- as.numeric(as.character(QCmetrics$Age))
betas <- betas(msetEPIC)
PredictedAge<-agep(betas,n_missing = F)
ReportedAge<-QCmetrics$Age
model<-lm(ReportedAge~PredictedAge)

ggplot(data = data.frame(x=PredictedAge , y=ReportedAge),aes(x = x , y = y))+
  geom_point()+
  geom_smooth(method = "lm" , formula = y~x)+
  ggtitle("Reported Age against Predicted Age")+
  xlab("Predicted")+
  ylab("Reported")+
  theme_bw()

QCmetrics<-cbind(QCmetrics, PredictedAge)

AgeCorTest <- cor.test(QCmetrics$Age, QCmetrics$PredictedAge)

```

We can see there is a correlation between predicted and reported ages in the samples `r AgeCorTest$estimate`(r=0.5). Generally, Horvath's clock doesn't predict as well in older and brain samples. The predicted ages are added to the QC output.


# Smoking Score
Smoking has well known associations with DNA methylation at sites across the genome. Using a method developed by Elliot et al. 2014 we can calculate a smoking score based on DNA methylation at these known sites, to predict smoking status.

A smoking score is calculated for each sample and a histogram of the scores is plotted below.
This score is most accurate in blood and bucal samples and is less accurate in brain tissue.

```{r calcsmokingscores, echo=FALSE}
#load function
source(paste0(ScriptDir,"/SmokingScoreFunction.R"))
## READ IN SMOKING DATA

#function takes betas matrix and returns a vector of calculated smoking scores
SmokingScore<-smokingscore(betas,ref_dir_path=paste0(ScriptDir,"/References"))
hist(SmokingScore, main="Histogram of Calculated Smoking Scores")
QCmetrics<-cbind(QCmetrics, SmokingScore)

```

For the relatively young age of these samples they have high smoking scores, however the smoking score is known to over predict the score in slavia/ bucccal samples 

<!--
# Tissue Prediction
```{r Tissue Prediction, echo =FALSE, message=FALSE, results= 'hide'}

#The model created by someone les and it doesn't work properlu for Brain samples. So, I removed this step. 
#load function 
# source(paste0(ScriptDir,"/Tissue_predictor_function.R"))
# 
# tissue.predictor <- tissue_predictor(betas,ref_dir_path=paste0(ScriptDir,"/References"))
# QCmetrics$Predicted_Tissue <- tissue.predictor$Predicted_Tissue
# ggplot(data = QCmetrics, aes(x=Organ, fill= Predicted_Tissue))+
#  geom_bar( position= position_dodge())+
#  labs(x = "Reported Tissue", fill= "Predicted Tissue") +
#  theme_minimal()
```
-->
# Pfilter
The pfilter function in the wateRmelon package filters data sets based on beadcounts and detection p-values.

## Beadcounts
If the percentage of samples with a beadcount less than 3 is greater than 5% for any probe, the probe is removed.

## Detection p-values
If the percentage of probes with a detection p-value less than 0.05 is greater than 1% for any sample, the sample is removed.

Similarly, if the percentage of samples with a detection p-value less than 0.05 is greater than 1% for any probe, the probe is removed.

```{r pfilterdefault, echo = FALSE, message = FALSE}
RGset.pf <- pfilter(RGset)

```

`r sum(!colnames(getBeta(RGset)) %in% colnames(getBeta(RGset.pf)))` out of `r nrow(SampleSheet)` samples fail the pfilter with these thresholds.

```{r update QCmetrics7, include=FALSE}
#remove the probes that failed the pfilter
msetEPIC<-msetEPIC[rownames(betas(msetEPIC)) %in% rownames(getBeta(RGset.pf)),]

#mark samples that fail the pfilter
pFilterPass<-colnames(betas(msetEPIC)) %in% colnames(RGset.pf)

QCmetrics<-cbind(QCmetrics,pFilterPass)
SamplesFail[which(pFilterPass==FALSE)]<-TRUE

#update QCmetrics and SamplesFailed
Step7<-c(length(which(pFilterPass==FALSE)),sum(SamplesFail))
Stepsummary<-cbind(Stepsummary,Step7)
```

```{r Stepsummary7}
print(Stepsummary)
```


# Outliers

The outlyx function in the wateRmelon package can be used to check if any of the remaining samples are classed as 'outliers' and should also be removed prior to normalisation. 


```{r outliers,echo= FALSE}
betas <- betas(msetEPIC)
outliers <- outlyx(betas)
QCmetrics <- cbind(QCmetrics, outliers$outliers)
SamplesFail[which(outliers$outliers == TRUE)]<-TRUE
Step8<-c(length(which(outliers$outliers == TRUE)),sum(SamplesFail))
Stepsummary<-cbind(Stepsummary,Step8)

```


```{r Stepsummary8}
print(Stepsummary)
```

`r sum(which(outliers$outliers == TRUE))` samples have been picked as being outliers using the outlyx function and have been removed prior to normalisation.


# Normalisation
The methylation data for just the passed samples and probes is quantile normalised using the dasen function from the wateRmelon package.

```{r normalisation, include=FALSE}
#then use dasen to normalise
msetEPIC.dasen.previo<-dasen(msetEPIC)

betas <- betas(msetEPIC)
betas.dasen <- betas(msetEPIC.dasen.previo)

normv <- qual(betas, betas.dasen)

# Define the upper threshold for outliers based on Interquartile Range (IQR)
# Anything above this value is considered an outlier
threshold <- round(quantile(normv$rmsd, probs = 0.75) + (3 * IQR(normv$rmsd , na.rm = T)) , digits = 2)
```

The 'qual' function in the wateRmelon package can be used to assess the degree of difference between normalised and raw betas. Those samples with Root Mean Square Deviation (RMSD) > (Q3+3*IQR(RMSD))=`r threshold` will be filter out.

```{r qual, echo = FALSE}

plot(normv[,1:2], main = "Normalisation Violence")
boxplot(normv$rmsd, main = "Normalisation Violence", ylab = "rmsd")
abline(h = threshold, col = "red", lty = 2, lwd = 2)

SamplesFail[which(normv[,1] >threshold)]<-TRUE

identical(rownames(QCmetrics), colnames(betas.dasen))

QCmetrics <- as.data.frame(as.matrix(QCmetrics))
QCmetrics$NormV <- NA
index <- match(rownames(normv) , rownames(QCmetrics))
QCmetrics$NormV[index] <- normv$rmsd
QCmetrics$NormV.Passed <- (QCmetrics$NormV  <= threshold)

Step9<-c(sum(QCmetrics$NormV >threshold, na.rm =TRUE),sum(SamplesFail))
Stepsummary<-cbind(Stepsummary,Step9)

```

```{r Stepsummary9}
print(Stepsummary)
```

Density plots of the beta values are plotted for each sample before and after normalisation below (separated by type I and type II probes). Samples with high normalisation violence will be removed.

```{r plot betas function, echo=FALSE}

#the inputs needed are your methylumiSet and a character string to give the plots a relevant title
plotmset_density<-function(mset, study=""){
	onetwo<-fData(mset)$DESIGN
	mat<-betas(mset)
	
	  plot(density(mat[onetwo=="I",1], na.rm=T, bw=0.03), cex.main=0.8, main=paste(study, "Betas"), ylim=c(0, 5.2), xlab="")
    lines(density(mat[onetwo=="II",1], na.rm=T, bw=0.03), col="red")

    for(j in 2:ncol(mat)){
		lines(density(mat[onetwo=="I",j], na.rm=T, bw=0.03))
		lines(density(mat[onetwo=="II",j], na.rm=T, bw=0.03), col="red")
    }
      
    legend("topright", legend=c("Type I", "Type II"), lty=1, col=c("black", "red")) 
}

#The more samples in your mset the more messy these plots will look
msetEPIC<-msetEPIC[,!SamplesFail]
msetEPIC.dasen<-dasen(msetEPIC)

plotmset_density(msetEPIC, study="Raw data")
plotmset_density(msetEPIC.dasen, study="Normalised Data")

#boxplot(log(unmethylated(msetEPIC)),main="raw data")
#boxplot(log(unmethylated(msetEPIC.dasen)),main="normalized data")

#double check dasen has not produced any values outside 0-1 (the number output is the number of samples that have any values outside 0-1)
raw.weird<-sum(colSums(betas(msetEPIC) > 1 | betas(msetEPIC) <0, na.rm=T) > 0)
#[1] 0
dasen.weird<-sum(colSums(betas(msetEPIC.dasen) > 1 | betas(msetEPIC.dasen) < 0) > 0)
#[1] 0 

```

The distributions generally look as we would expect, and dasen has not caused any samples to have beta values outside the expected 0-1 range. 

There should be no points failing the second normalisation step as they will have been removed previously


# Cell Composition
DNA methylation varies between different cell types, and so the composition of cell types can significantly affect the methylation of samples. Therefore, estimations of cell-type composition is an important variable to consider when analysing this type of data.In order to estimate the cell proportions, we use an function estimateCellCounts in the R package Minfi, developed by Hansen et al and CETYGO package developped by Hannon et al. For more information you can visit https://github.com/ejh243/CETYGO.  

```{r cellcomposition, echo=FALSE, warning= FALSE, message = FALSE}

message("Estimating cell types...")
source(paste0(ScriptDir,"/CETYGO.R"))
flag = F
Organ <- SampleSheet$Organ[!(is.na(SampleSheet$Organ) | SampleSheet$Organ == "NA" | SampleSheet$Organ == "NAN")]
betas <- betas(msetEPIC)
if(all(tolower(Organ)=="blood")){
  
  CT.CETYGO = adultBloodCETYGO(betas)
  print(CT.CETYGO$Plot2)
  
  print(CT.CETYGO$Plot1)
  
  CT.CETYGO.data <- CT.CETYGO$Data[match(SampleSheet$Basename, rownames(CT.CETYGO$Data)),]
  QCmetrics<-cbind(QCmetrics, CT.CETYGO.data)
  
  CT.minfi <- estimateCellCounts(RGset, compositeCellType ="Blood", cellTypes = c("CD8T","CD4T", "NK","Bcell","Mono","Gran"), processMethod = "auto")
  flag = T
  save(CT.minfi, CT.CETYGO, file=paste0(OutPrefix,".CellCounts.rdat"))
  message("CellCount created and saved in ", paste0(OutPrefix,".CellCounts.rdat"))
  
} else if(all(tolower(Organ) == "brain")){
  
  # if(all(is.na(SampleSheet$Cell_Type))){
  #   CT.obj = adultBrainCETYGO(betas, "bulk")
  # }else{
  #   for(cell in levels(sampleSheet$Cell_Type)) {
  #   cellSampleSheet <- sampleSheet[which(sampleSheet$Cell_Type == cell), ]
  #   cellBetas <- betas[, colnames(betas) %in% cellSampleSheet$Basename]
  #   adultBrainCETYGO(cellBetas, cell)
  #   }
  # }
  
  CT.CETYGO = adultBrainCETYGO(betas, "bulk")
  CETYGO = CT.CETYGO$Data
  
  print(CT.CETYGO$Plot2[[2]] + scale_x_discrete(labels=c("IRF8Pos","NeuNPos","SOX10Pos","Trip_Neg")))
  
  print(CT.CETYGO$Plot1[[2]])
  
  CT.CETYGO.IDOL <- CT.CETYGO$Data$IDOL[[2]][match(SampleSheet$Basename, rownames(CT.CETYGO$Data$IDOL[[2]])),]
  colnames(CT.CETYGO.IDOL)[1:4] <- c("IRF8Pos","NeuNPos","SOX10Pos","Trip_Neg")
  QCmetrics<-cbind(QCmetrics, CT.CETYGO.IDOL)
  
  CT.minfi <- estimateCellCounts(RGset, compositeCellType ="DLPFC",cellTypes=c("NeuN_neg" ,"NeuN_pos"))
  
  flag=T
  
  save(CT.minfi , CT.CETYGO, file=paste0(OutPrefix,".CellCounts.rdat"))
  
  message("CellCount created and saved in ", paste0(OutPrefix,".CellCounts.rdat"))
  
}else if(all(tolower(Organ)=="cordblood")){
  
  CT.minfi <- estimateCellCounts(RGset, compositeCellType ="CordBlood",cellTypes=c("Bcell", "CD4T", "CD8T", "Gran", "Mono", "Neu", "nRBC"))
  flag=T
  save(CT.minfi, file=paste0(OutPrefix,".CellCounts.rdat"))
  message("CellCount created and saved in ", paste0(OutPrefix,".CellCounts.rdat"))
  
}else {
  
  message("Estimating cell type failed: Multiple/No Organ presented in samplesheet file!")
  
}



if(flag){
  CT.minfi<-CT.minfi[match(SampleSheet$Basename, rownames(CT.minfi)),]
  QCmetrics<-cbind(QCmetrics, CT.minfi)
  
  ##Add cell density plots
  CT.minfi.m <- melt(CT.minfi,"colnames")
  i <- sapply(CT.minfi.m, is.factor) #gets rid of factos in data frame
  CT.minfi.m[i] <- lapply(CT.minfi.m[i], as.character)
  colnames(CT.minfi.m) <- c("Samples","Cell","Proportion")
  
  boxplot(CT.minfi, use.cols=T, main="Boxplot of Estimated Cell Proportions")
  
  ggplot(CT.minfi.m, aes(x = Proportion)) +
    geom_density(alpha = 0.5,color="darkblue", fill="lightblue") +
    facet_wrap( ~ Cell) +
    labs(x = "", y = "Density",
         title = ("Cell Distribution")) +
    theme(panel.background = element_blank()) +
    scale_fill_brewer(palette = "Set1")
}

```

The estimated cell proportions are added to the QC output and can be used as covariates in later analyses.


# QC Summary 

The QC results for the `r sum(SamplesFail)` failed samples and `r sum(!SamplesFail)` passed samples are saved to `r SamplesFailed` and `r SamplesPassed` respectively.

SNP probes, probes containing common SNPs, and probes with non-specific binding are removed at this stage to prevent technical artifacts influencing the results in later analyses.

Finally the QCed, normalised and filtered dataset is saved to `r Normalised` ready for subsequent analysis.

```{r saveoutput, include=FALSE}

write.csv(QCmetrics[SamplesFail,], SamplesFailed, row.names = F)
write.csv(QCmetrics[!SamplesFail,], SamplesPassed, row.names = F)

#filter probes from normalised betas
betas<-betas(msetEPIC.dasen)

# crosshyb<-read.table("/mnt/data1/EPIC_reference/CrossHydridisingProbes_McCartney.txt", stringsAsFactors = FALSE)
# snpProbes<-read.table("/mnt/data1/EPIC_reference/SNPProbes_McCartney.txt", stringsAsFactors = FALSE, header = TRUE)
# snpProbes<-snpProbes[which(snpProbes$EUR_AF >= 0.05 & snpProbes$EUR_AF <= 0.95),]
# 
# betas<-betas[!(rownames(betas) %in% crosshyb[,1]), ]
# betas<-betas[!(rownames(betas) %in% unique(snpProbes$IlmnID)), ]
betas<-betas[-grep("rs", rownames(betas)),]

#only keeping the useful variables in SampleSheet
SampleSheet<-QCmetrics[!SamplesFail,]



# SampleSheet <- subset(SampleSheet, select = - c(Name_QC,Name_lab,Empty, position, Control, Intensity,Bisulphite, PredictedSex,MismatchSex,PredictedAge,pFilterPass,NormV))


betas<-betas[,match(SampleSheet$Basename, colnames(betas))]

SampleSheet <- SampleSheet[order(rownames(SampleSheet)),]
betas <- betas[,order(colnames(betas))]

if(identical(rownames(SampleSheet), colnames(betas))){
  save(SampleSheet, betas, file = Normalised)
  message("Sample Sheet and Betas Match QC'd object is saved")
}else{
  exit()
  message("Sample Sheet and Betas do not match QC'd object is not saved")
}

```

The final dataset contains `r nrow(SampleSheet)` samples and `r nrow(betas)` probes.

